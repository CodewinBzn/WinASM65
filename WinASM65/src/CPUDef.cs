/**********************************************************************************/
/*                                                                                */
/*                                                                                */
/* 2021 Abdelghani BOUZIANE                                                       */
/*                                                                                */
/*                                                                                */
/**********************************************************************************/

using System.Collections.Generic;
using System.Text.RegularExpressions;
namespace WinASM65
{
    public class CPUDef
    {

        public const string Label = "LABEL";
        public const string Directive = "DIRECTIVE";
        public const string Instruction = "INSTRUCTION";
        public const string Constant = "CONSTANT";
        public const string MemReserve = "MEM_RESERVE";
        public const string CallMacro = "CALL_MACRO";
        public const string StartLocalScope = "START_LOCAL_SCOPE";
        public const string EndLocalScope = "END_LOCAL_SCOPE";

        public enum AddrModes
        {
            NO = -1,
            IMP = 0,        // OPC
            ACC = 1,        // OPC A
            IMM = 2,        // OPC #byte
            ABS = 3,        // OPC word
            ABX = 4,        // OPC word,X
            ABY = 5,        // OPC word,Y
            ZPG = 6,        // OPC byte         
            ZPX = 7,        // OPC byte,X       
            ZPY = 8,        // OPC byte,Y       
            IND = 9,        // OPC (word)
            INX = 10,       // OPC (byte,x)
            INY = 11,       // OPC (byte),y
            REL = 12,       // OPC byte
        }                                                                    

        public static readonly string[] RelOpc = new string[] { "BCC", "BCS", "BEQ", "BMI", "BNE", "BPL", "BVC", "BVS" };
        public static readonly string[] AccOpc = new string[] { "ASL ", "LSR", "ROL", "ROR" };
        public static readonly Dictionary<string, byte[]> OpcTable = new Dictionary<string, byte[]>
        {
            { "ADC", new byte[] {0xff, 0xff, 0x69, 0x6d, 0x7d, 0x79, 0x65, 0x75, 0xff, 0xff, 0x61, 0x71, 0xff } },
            { "AND", new byte[] {0xff,  0xff,0x29,0x2d,0x3d,0x39,0x25,0x35,  0xff,  0xff,0x21,0x31,  0xff}},
            { "ASL", new byte[] {0xff,0x0a,  0xff,0x0e,0x1e,  0xff,0x06,0x16,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "BCC", new byte[] {0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,0x90}},
            { "BCS", new byte[] {0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,0xb0}},
            { "BEQ", new byte[] {0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,0xf0}},
            { "BIT", new byte[] {0xff,  0xff,  0xff,0x2c,  0xff,  0xff,0x24,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "BMI", new byte[] {0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,0x30}},
            { "BNE", new byte[] {0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,0xd0}},
            { "BPL", new byte[] {0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,0x10}},
            { "BRK", new byte[] {0x00,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "BVC", new byte[] {0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,0x50}},
            { "BVS", new byte[] {0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,0x70}},
            { "CLC", new byte[] {0x18,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "CLD", new byte[] {0xd8,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "CLI", new byte[] {0x58,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "CLV", new byte[] {0xb8,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "CMP", new byte[] {0xff,  0xff,0xc9,0xcd,0xdd,0xd9,0xc5,0xd5,  0xff,  0xff,0xc1,0xd1,  0xff}},
            { "CPX", new byte[] {0xff,  0xff,0xe0,0xec,  0xff,  0xff,0xe4,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "CPY", new byte[] {0xff,  0xff,0xc0,0xcc,  0xff,  0xff,0xc4,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "DEC", new byte[] {0xff,  0xff,  0xff,0xce,0xde,  0xff,0xc6,0xd6,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "DEX", new byte[] {0xca,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "DEY", new byte[] {0x88,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "EOR", new byte[] {0xff,  0xff,0x49,0x4d,0x5d,0x59,0x45,0x55,  0xff,  0xff,0x41,0x51,  0xff}},
            { "INC", new byte[] {0xff,  0xff,  0xff,0xee,0xfe,  0xff,0xe6,0xf6,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "INX", new byte[] {0xe8,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "INY", new byte[] {0xc8,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "JMP", new byte[] {0xff,  0xff,  0xff,0x4c,  0xff,  0xff,  0xff,  0xff,  0xff,0x6c,  0xff,  0xff,  0xff}},
            { "JSR", new byte[] {0xff,  0xff,  0xff,0x20,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "LDA", new byte[] {0xff,  0xff,0xa9,0xad,0xbd,0xb9,0xa5,0xb5,  0xff,  0xff,0xa1,0xb1,  0xff}},
            { "LDX", new byte[] {0xff,  0xff,0xa2,0xae,  0xff,0xbe,0xa6,  0xff,0xb6,  0xff,  0xff,  0xff,  0xff}},
            { "LDY", new byte[] {0xff,  0xff,0xa0,0xac,0xbc,  0xff,0xa4,0xb4,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "LSR", new byte[] {0xff,0x4a,  0xff,0x4e,0x5e,  0xff,0x46,0x56,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "NOP", new byte[] {0xea,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "ORA", new byte[] {0xff,  0xff,0x09,0x0d,0x1d,0x19,0x05,0x15,  0xff,  0xff,0x01,0x11,  0xff}},
            { "PHA", new byte[] {0x48,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "PHP", new byte[] {0x08,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "PLA", new byte[] {0x68,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "PLP", new byte[] {0x28,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "ROL", new byte[] {0xff,0x2a,  0xff,0x2e,0x3e,  0xff,0x26,0x36,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "ROR", new byte[] {0xff,0x6a,  0xff,0x6e,0x7e,  0xff,0x66,0x76,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "RTI", new byte[] {0x40,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "RTS", new byte[] {0x60,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "SBC", new byte[] {0xff,  0xff,0xe9,0xed,0xfd,0xf9,0xe5,0xf5,  0xff,  0xff,0xe1,0xf1,  0xff}},
            { "SEC", new byte[] {0x38,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "SED", new byte[] {0xf8,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "SEI", new byte[] {0x78,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "STA", new byte[] {0xff,  0xff,  0xff,0x8d,0x9d,0x99,0x85,0x95,  0xff,  0xff,0x81,0x91,  0xff}},
            { "STX", new byte[] {0xff,  0xff,  0xff,0x8e,  0xff,  0xff,0x86,  0xff,0x96,  0xff,  0xff,  0xff,  0xff}},
            { "STY", new byte[] {0xff,  0xff,  0xff,0x8c,  0xff,  0xff,0x84,0x94,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "TAX", new byte[] {0xaa,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "TAY", new byte[] {0xa8,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "TSX", new byte[] {0xba,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "TXA", new byte[] {0x8a,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "TXS", new byte[] {0x9a,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}},
            { "TYA", new byte[] {0x98,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff}}
        };

        // regex
        public static readonly Regex LabelDeclareReg = new Regex(@"\s*" + Tokenizer.LabelRegex + @":\s*", RegexOptions.Compiled);
        public static readonly Regex DirectiveReg = new Regex(@"\s*(?<directive>\.[a-zA-Z]+)(\s+(?<value>(.)+))?", RegexOptions.Compiled);
        // instruction = label? opcode operands?
        public static readonly Regex InstrReg = new Regex(@"^(\s*" + Tokenizer.LabelRegex + @"\s+)?(?<opcode>[a-zA-Z]{3})((\s+(?<operands>(.)+))|$)", RegexOptions.Compiled);
        public static readonly Regex ConstantReg = new Regex(@"^\s*" + Tokenizer.LabelRegex + @"\s*=\s*(?<value>(.)+)$", RegexOptions.Compiled);
        public static readonly Regex MemResReg = new Regex(@"^\s*" + Tokenizer.LabelRegex + @"\s+\.(RES|res)\s+(?<value>(.)+)$", RegexOptions.Compiled);
        public static readonly Regex MacroReg = new Regex(@"^(\s*" + Tokenizer.LabelRegex + @")(\s+(?<value>(.)+))?", RegexOptions.Compiled);
        private static readonly Regex StartLocalScopeRegex = new Regex(@"^\s*\{\s*", RegexOptions.Compiled);
        private static readonly Regex EndLocalScopeRegex = new Regex(@"^\s*\}\s*", RegexOptions.Compiled);

        public static readonly Dictionary<Regex, string> RegMap = new Dictionary<Regex, string>
        {
            { StartLocalScopeRegex, StartLocalScope},
            { EndLocalScopeRegex, EndLocalScope},
            { LabelDeclareReg, Label},
            { MemResReg, MemReserve },
            { DirectiveReg, Directive},
            { ConstantReg, Constant },
            { InstrReg, Instruction},
            { MacroReg, CallMacro }
        };

        public struct InstructionInfo
        {
            public AddrModes AddrMode { get; set; }
            public ushort NbrBytes { get; set; }
            public string Expr { get; set; }

        }

        public static readonly Dictionary<AddrModes, InstructionInfo> InstrInfoByAddrMode = new Dictionary<AddrModes, InstructionInfo>
        {
            { AddrModes.IMM, new InstructionInfo {AddrMode = AddrModes.IMM, NbrBytes= 2}},
            { AddrModes.ABX, new InstructionInfo {AddrMode = AddrModes.ABX, NbrBytes= 3}},
            { AddrModes.ABY, new InstructionInfo {AddrMode = AddrModes.ABY, NbrBytes= 3}},
            { AddrModes.INX, new InstructionInfo {AddrMode = AddrModes.INX, NbrBytes= 2}},
            { AddrModes.INY, new InstructionInfo {AddrMode = AddrModes.INY, NbrBytes= 2}},
            { AddrModes.IND, new InstructionInfo {AddrMode = AddrModes.IND, NbrBytes= 3}},
            { AddrModes.ABS, new InstructionInfo {AddrMode = AddrModes.ABS, NbrBytes= 3}},
        };

        public static bool IsAbsoluteAddr(AddrModes addrMode)
        {
            return ((int)addrMode < 6 && (int)addrMode > 2);
        }
        public static bool IsString(string value)
        {
            return value.StartsWith("\"") && value.EndsWith("\"");
        }


        // IMP, ACC, REL and zero page are managed outside
        public static InstructionInfo GetInstructionInfo(string str)
        {
            InstructionInfo instInfo;
            string inst = Regex.Replace(str, @"\s+", "");
            if (inst.StartsWith("#"))
            {
                instInfo = InstrInfoByAddrMode[AddrModes.IMM];
                instInfo.Expr = inst.Remove(0, 1);
                return instInfo;
            }
            if (inst.EndsWith(",x") || inst.EndsWith(",X"))
            {
                instInfo = InstrInfoByAddrMode[AddrModes.ABX];
                instInfo.Expr = inst.Remove(inst.Length - 2, 2);
                return instInfo;
            }
            if (inst.StartsWith("(") && (inst.EndsWith(",x)") || inst.EndsWith(",X)")))
            {
                instInfo = InstrInfoByAddrMode[AddrModes.INX];
                instInfo.Expr = inst.Remove(inst.Length - 3, 3).Remove(0, 1);
                return instInfo;
            }
            if (inst.StartsWith("(") && (inst.EndsWith("),y") || inst.EndsWith("),Y")))
            {
                instInfo = InstrInfoByAddrMode[AddrModes.INY];
                instInfo.Expr = inst.Remove(inst.Length - 3, 3).Remove(0, 1);
                return instInfo;
            }
            if (inst.EndsWith(",y") || inst.EndsWith(",Y"))
            {
                instInfo = InstrInfoByAddrMode[AddrModes.ABY];
                instInfo.Expr = inst.Remove(inst.Length - 2, 2);
                return instInfo;
            }
            if (inst.StartsWith("(") && inst.EndsWith(")"))
            {
                instInfo = InstrInfoByAddrMode[AddrModes.IND];
                instInfo.Expr = inst.Remove(inst.Length - 1, 1).Remove(0, 1);
                return instInfo;
            }

            instInfo = InstrInfoByAddrMode[AddrModes.ABS];
            instInfo.Expr = inst;
            return instInfo;
        }
    }

}
